<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2025 Memory Hallway/title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background-color: #000;
                font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            }

            #ui-layer {
                position: fixed;
                top: 20px;
                width: 100%;
                text-align: center;
                color: white;
                pointer-events: none;
                z-index: 10;
            }

            .instruction {
                background: rgba(0, 0, 0, 0.6);
                backdrop-filter: blur(5px);
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 12px;
                letter-spacing: 1px;
                display: inline-block;
                border: 1px solid rgba(255, 255, 255, 0.1);
            }

            /* ÂΩàÂá∫Ë¶ñÁ™óÊ®£Âºè */
            #modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.85);
                backdrop-filter: blur(8px);
                z-index: 100;
                display: none;
                justify-content: center;
                align-items: center;
                opacity: 0;
                transition: opacity 0.3s ease;
            }

            #modal-content {
                background: white;
                width: 90%;
                max-width: 400px;
                padding: 20px;
                border-radius: 15px;
                text-align: center;
                transform: scale(0.8);
                transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                position: relative;
            }

            #modal-img {
                width: 100%;
                height: auto;
                max-height: 60vh;
                object-fit: contain;
                border-radius: 8px;
                margin-bottom: 15px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
                transition: none;
            }

            #modal-img.slide-in {
                animation: slideInFromLeft 0.5s ease-out;
            }

            @keyframes slideInFromLeft {
                from {
                    transform: translateX(-100%);
                    opacity: 0;
                }

                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }

            #modal-name {
                font-size: 24px;
                font-weight: bold;
                margin: 0;
                color: #333;
            }

            #modal-title {
                font-size: 16px;
                color: #d4a373;
                font-weight: bold;
                margin: 5px 0 15px 0;
                text-transform: uppercase;
                letter-spacing: 1px;
            }

            #modal-desc {
                font-size: 14px;
                color: #666;
                line-height: 1.6;
                margin-bottom: 20px;
                font-style: italic;
            }

            #close-btn {
                background: #333;
                color: white;
                border: none;
                padding: 10px 30px;
                border-radius: 25px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
            }

            .slideshow-controls {
                display: none;
                justify-content: center;
                gap: 15px;
                margin: 10px 0;
            }

            .slideshow-controls.active {
                display: flex;
            }

            .nav-btn {
                background: #4a90e2;
                color: white;
                border: none;
                padding: 8px 20px;
                border-radius: 20px;
                cursor: pointer;
                font-weight: bold;
                font-size: 14px;
                transition: background 0.3s;
            }

            .nav-btn:hover {
                background: #357abd;
            }

            .nav-btn:disabled {
                background: #ccc;
                cursor: not-allowed;
            }

            #slide-counter {
                color: #666;
                font-size: 14px;
                font-weight: bold;
                padding: 8px 15px;
            }

            canvas {
                cursor: grab;
            }

            canvas:active {
                cursor: grabbing;
            }
        </style>
</head>

<body>

    <div id="ui-layer">
        <div class="instruction">Use scroll/2-finger hold to navigate.</div>
    </div>

    <!-- Permission Overlay (Required for iOS) -->
    <div id="permission-overlay"
        style="display:none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 200; justify-content: center; align-items: center; flex-direction: column; color: white; text-align: center;">
        <h2>Enable Motion Control</h2>
        <p>Allow access to device orientation for the full experience.</p>
        <button id="start-btn" onclick="requestOrientationPermission()"
            style="background: #d86a95; border: none; padding: 15px 40px; border-radius: 30px; color: white; font-size: 20px; margin-top: 20px; font-weight: bold;">Start
            Experience</button>
    </div>

    <div id="modal-overlay" onclick="closeModal()">
        <div id="modal-content" onclick="event.stopPropagation()">
            <img id="modal-img" src="" alt="Friend Photo">
            <h2 id="modal-name">Name</h2>
            <div id="modal-title">Title</div>
            <p id="modal-desc">Description</p>
            <div class="slideshow-controls" id="slideshow-controls">
                <button class="nav-btn" id="prev-btn" onclick="navigateSlide(-1)">‚Üê Prev</button>
                <span id="slide-counter">1 / 5</span>
                <button class="nav-btn" id="next-btn" onclick="navigateSlide(1)">Next ‚Üí</button>
            </div>
            <button id="close-btn" onclick="closeModal()">Close</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. Ë≥áÊñôÂçÄ ---
        const friendsData = [
            {
                name: "Carrie",
                title: "Chief Cocoa Officer",
                file: '3d_images/carrie.jpg',
                desc: "Once ate a whole chocolate fondue fountain by herself. Stocks went up."
            },
            {
                name: "Anna",
                title: "The Dairy Gambler",
                file: '3d_images/anna.jpg',
                desc: "Will risk it all for a slice of tiramisu. Brave soul."
            },
            {
                name: "Winni",
                title: "CEO of 3AM",
                file: '3d_images/winni.jpg',
                desc: "Hasn't seen the sun since 2024. Operates purely on moonlight."
            },
            {
                name: "Aska",
                title: "The Tear Vending Machine",
                file: '3d_images/aska.jpg',
                desc: "Fluent in multiple languages, but cries in universal. A pure soul who needs a tissue subscription."
            },
            {
                name: "Carlos",
                title: "Lord of Time",
                file: '3d_images/carlos.jpg',
                desc: "Juggles jobs, dating, TAing, and gaming simultaneously. Rumor has it he discovered the 25th hour of the day."
            },
            {
                name: "Anthony",
                title: "The Hotpot Evangelist",
                file: '3d_images/anthony.jpg',
                desc: "Survives on broccoli and chicken breast just to inhale a whole pizza later. His love language is spamming 'HOTPOT?' in the group chat."
            },
            {
                name: "Erioe",
                title: "The Fragrant Carry",
                file: '3d_images/erioe.jpg',
                desc: "A fashion icon with a PhD in perfumes. He treats every hallway like a runway and always smells expensive."
            },
            {
                name: "Aimee",
                title: "The Marathon Caller",
                file: '3d_images/aimee.jpg',
                desc: "Queen of deals and 3-hour daily calls with her bf. A long-distance warrior who spams us with her boyfriend's cat photos."
            }
        ];

        // --- ÂõõÂ≠£ÈÖçËâ≤ ---
        const seasonsConfig = [
            {
                id: "spring",
                floor: '#2d6a4f', wall: '#d8f3dc', ceiling: '#b7e4c7',
                artFolder: '3d_images/spring'
            },
            {
                id: "summer",
                floor: '#e9c46a', wall: '#caf0f8', ceiling: '#90e0ef',
                artFolder: '3d_images/summer'
            },
            {
                id: "autumn",
                floor: '#7f5539', wall: '#faedcd', ceiling: '#fefae0',
                artFolder: '3d_images/autumn'
            },
            {
                id: "winter",
                floor: '#4a4e69', wall: '#f1faee', ceiling: '#a8dadc',
                artFolder: '3d_images/winter'
            }
        ];

        let scene, camera, renderer;
        let lon = 0, lat = 0;
        let cameraZ = 0, targetZ = 0;

        // Ë®≠ÂÆöÈñìË∑ù
        const SPACING = 800; // ÊúãÂèã‰πãÈñìÁöÑÈñìË∑ù
        const SEASON_LENGTH = 1200; // ÊØèÂÄãÂ≠£ÁØÄÁöÑÈï∑Â∫¶

        let isUserInteracting = false;
        let onPointerDownPointerX = 0, onPointerDownPointerY = 0;
        let onPointerDownLon = 0, onPointerDownLat = 0;
        let isDragging = false;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const interactableObjects = [];
        const particles = []; // Store particle systems

        // Slideshow Variables
        let currentSlideIndex = 0;
        let slideshowImages = [];
        let slideshowActive = false;

        // Mobile Logic Variables
        let isTwoFingerTouching = false;
        let isMobile = false;
        let baseAlpha = null;

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 200, 3000);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            // --- 2. Âª∫Á´ãÂàÜÊÆµÂºèÁí∞Â¢É (ÂõõÂ≠£) ---
            createSeasonalEnvironment();

            // --- 3. Âª∫Á´ãÊúãÂèãÊòüÊòü ---
            createFriendStars();

            // --- 4. Âª∫Á´ãÊ®ôÊ∫ñÊéíÂàóÁöÑÁï´Ê°Ü ---
            createStandardGallery();

            // Ê∏≤ÊüìÂô®
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Ê®ôÈ°å
            addEntranceText();

            // ‰∫ã‰ª∂Áõ£ËÅΩ
            document.addEventListener('mousedown', onPointerDown, false);
            document.addEventListener('mousemove', onPointerMove, false);
            document.addEventListener('mouseup', onPointerUp, false);
            document.addEventListener('touchstart', onTouchStart, { passive: false });
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd, false);
            document.addEventListener('wheel', onDocumentMouseWheel, { passive: false });
            window.addEventListener('click', onMouseClick, false);
            window.addEventListener('resize', onWindowResize);
        }

        // --- Utils: Generate Procedural Textures ---
        function createTextureFromCanvas(drawFn, width = 256, height = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = width; canvas.height = height;
            const ctx = canvas.getContext('2d');
            drawFn(ctx, width, height);
            return new THREE.CanvasTexture(canvas);
        }

        // Decoration Generators
        const DecorationSet = {
            ChristmasTree: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                // Tree
                ctx.fillStyle = '#2d6a4f';
                ctx.beginPath();
                ctx.moveTo(w / 2, 20);
                ctx.lineTo(w - 40, h - 60);
                ctx.lineTo(40, h - 60);
                ctx.fill();
                // Pot
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(w / 2 - 20, h - 60, 40, 40);
                // Ornaments
                for (let i = 0; i < 10; i++) {
                    ctx.beginPath();
                    ctx.arc(40 + Math.random() * (w - 80), 60 + Math.random() * (h - 120), 8, 0, Math.PI * 2);
                    ctx.fillStyle = ['#c1121f', '#fdf0d5', '#ffd700'][Math.floor(Math.random() * 3)];
                    ctx.fill();
                }
                // Star
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(w / 2, 20, 10, 0, Math.PI * 2);
                ctx.fill();
            },
            Mistletoe: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                ctx.translate(w / 2, 0);
                // Leaves
                ctx.fillStyle = '#55a630';
                for (let i = 0; i < 6; i++) {
                    ctx.save();
                    ctx.rotate(Math.PI / 6 * (i - 2.5));
                    ctx.beginPath();
                    ctx.ellipse(0, 60, 20, 50, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                // Berries
                ctx.fillStyle = '#e63946';
                ctx.beginPath(); ctx.arc(-15, 60, 10, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(15, 60, 10, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(0, 80, 10, 0, Math.PI * 2); ctx.fill();
            },
            Flower: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                // Petals
                ctx.translate(w / 2, h / 2);
                ctx.fillStyle = '#fb6f92';
                for (let i = 0; i < 8; i++) {
                    ctx.rotate(Math.PI / 4);
                    ctx.beginPath();
                    ctx.ellipse(60, 0, 40, 20, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Center
                ctx.fillStyle = '#ffb703';
                ctx.beginPath();
                ctx.arc(0, 0, 30, 0, Math.PI * 2);
                ctx.fill();
            },
            Sun: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                ctx.translate(w / 2, h / 2);
                // Rays
                ctx.fillStyle = '#ffbe0b';
                for (let i = 0; i < 12; i++) {
                    ctx.rotate(Math.PI / 6);
                    ctx.fillRect(60, -5, 60, 10);
                }
                // Core
                ctx.fillStyle = '#fb5607';
                ctx.beginPath();
                ctx.arc(0, 0, 60, 0, Math.PI * 2);
                ctx.fill();
            },
            Pumpkin: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                ctx.fillStyle = '#e66200'; // Orange
                ctx.beginPath();
                ctx.ellipse(w / 2, h / 2 + 10, 80, 60, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(w / 2 - 30, h / 2 + 10, 40, 60, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(w / 2 + 30, h / 2 + 10, 40, 60, 0, 0, Math.PI * 2);
                ctx.fill();
                // Stem
                ctx.fillStyle = '#4a6fa5';
                ctx.fillRect(w / 2 - 10, h / 2 - 60, 20, 30);
                // Eyes
                ctx.fillStyle = '#222';
                ctx.beginPath(); ctx.moveTo(w / 2 - 40, h / 2 - 10); ctx.lineTo(w / 2 - 20, h / 2 - 10); ctx.lineTo(w / 2 - 30, h / 2 - 30); ctx.fill();
                ctx.beginPath(); ctx.moveTo(w / 2 + 20, h / 2 - 10); ctx.lineTo(w / 2 + 40, h / 2 - 10); ctx.lineTo(w / 2 + 30, h / 2 - 30); ctx.fill();
                // Mouth
                ctx.beginPath(); ctx.arc(w / 2, h / 2 + 20, 30, 0, Math.PI, false); ctx.fill();
            },

            // --- Winter ---
            PinkSantaIceCream: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                const cx = w / 2;
                const cy = h / 2 + 20;

                // Cone
                ctx.fillStyle = '#d4a373';
                ctx.beginPath();
                ctx.moveTo(cx - 20, cy);
                ctx.lineTo(cx + 20, cy);
                ctx.lineTo(cx, cy + 60);
                ctx.fill();

                // Grid on cone
                ctx.strokeStyle = '#b07d62'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx - 15, cy); ctx.lineTo(cx, cy + 45); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx + 15, cy); ctx.lineTo(cx, cy + 45); ctx.stroke();

                // Scoops (Pink!)
                ctx.fillStyle = '#ff69b4'; // Hot Pink
                ctx.beginPath(); ctx.arc(cx - 15, cy - 10, 20, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx + 15, cy - 10, 20, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx, cy - 25, 22, 0, Math.PI * 2); ctx.fill();

                // Santa Hat
                // Red part
                ctx.fillStyle = '#d00000';
                ctx.beginPath();
                ctx.moveTo(cx - 25, cy - 40);
                ctx.lineTo(cx + 25, cy - 40);
                ctx.lineTo(cx + 15, cy - 80); // Tip leans right
                ctx.fill();

                // White Trim
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.roundRect(cx - 28, cy - 40, 56, 12, 6);
                ctx.fill();

                // Pom Pom
                ctx.beginPath();
                ctx.arc(cx + 15, cy - 80, 8, 0, Math.PI * 2);
                ctx.fill();
            },

            Snowman: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                const cx = w / 2;
                const bottomY = h - 20;

                // Body (Bottom)
                ctx.fillStyle = '#ffffff';
                ctx.beginPath(); ctx.arc(cx, bottomY - 30, 30, 0, Math.PI * 2); ctx.fill();
                // Body (Middle)
                ctx.beginPath(); ctx.arc(cx, bottomY - 75, 22, 0, Math.PI * 2); ctx.fill();
                // Head
                ctx.beginPath(); ctx.arc(cx, bottomY - 110, 16, 0, Math.PI * 2); ctx.fill();

                // Eyes & Buttons
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(cx - 5, bottomY - 115, 2, 0, Math.PI * 2); // Eye L
                ctx.arc(cx + 5, bottomY - 115, 2, 0, Math.PI * 2); // Eye R
                ctx.arc(cx, bottomY - 75, 2, 0, Math.PI * 2); // Button 1
                ctx.arc(cx, bottomY - 65, 2, 0, Math.PI * 2); // Button 2
                ctx.fill();

                // Nose
                ctx.fillStyle = '#e66200';
                ctx.beginPath(); ctx.moveTo(cx, bottomY - 110); ctx.lineTo(cx + 15, bottomY - 108); ctx.lineTo(cx, bottomY - 106); ctx.fill();

                // Scarf
                ctx.strokeStyle = '#e63946';
                ctx.lineWidth = 5;
                ctx.beginPath(); ctx.moveTo(cx - 12, bottomY - 95); ctx.quadraticCurveTo(cx, bottomY - 85, cx + 12, bottomY - 95); ctx.stroke();
            },

            // --- Spring ---
            Butterfly: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                ctx.translate(w / 2, h / 2);

                // Wings
                ctx.fillStyle = '#cdb4db';
                ctx.beginPath();
                ctx.ellipse(-20, -20, 30, 40, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(20, -20, 30, 40, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ffc8dd';
                ctx.beginPath();
                ctx.ellipse(-15, 20, 20, 25, -Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(15, 20, 20, 25, Math.PI / 4, 0, Math.PI * 2);
                ctx.fill();

                // Body
                ctx.fillStyle = '#333';
                ctx.beginPath(); ctx.ellipse(0, 0, 5, 30, 0, 0, Math.PI * 2); ctx.fill();

                // Antenna
                ctx.strokeStyle = '#333'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(0, -25); ctx.quadraticCurveTo(-10, -40, -15, -35); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, -25); ctx.quadraticCurveTo(10, -40, 15, -35); ctx.stroke();
            },

            // --- Summer ---
            IceCream: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                const cx = w / 2;
                const cy = h / 2 + 20;

                // Cone
                ctx.fillStyle = '#d4a373';
                ctx.beginPath();
                ctx.moveTo(cx - 20, cy);
                ctx.lineTo(cx + 20, cy);
                ctx.lineTo(cx, cy + 60);
                ctx.fill();

                // Grid on cone
                ctx.strokeStyle = '#b07d62'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(cx - 15, cy); ctx.lineTo(cx, cy + 45); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx + 15, cy); ctx.lineTo(cx, cy + 45); ctx.stroke();

                // Scoops
                ctx.fillStyle = '#ffb7b2';
                ctx.beginPath(); ctx.arc(cx - 15, cy - 10, 20, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#a2d2ff';
                ctx.beginPath(); ctx.arc(cx + 15, cy - 10, 20, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#fffdd0';
                ctx.beginPath(); ctx.arc(cx, cy - 25, 22, 0, Math.PI * 2); ctx.fill();
            },

            // --- Autumn ---
            Mushroom: (ctx, w, h) => {
                ctx.clearRect(0, 0, w, h);
                const cx = w / 2;
                const cy = h / 2;

                // Stem
                ctx.fillStyle = '#fefae0';
                ctx.beginPath();
                ctx.rect(cx - 15, cy, 30, 50);
                ctx.fill();

                // Cap (Red top)
                ctx.fillStyle = '#d90429';
                ctx.beginPath();
                ctx.arc(cx, cy, 45, Math.PI, 0);
                ctx.fill();

                // Dots on cap
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(cx - 20, cy - 20, 6, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx + 20, cy - 15, 8, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(cx, cy - 35, 5, 0, Math.PI * 2); ctx.fill();
            }
        };

        // --- Catchphrases Array ---
        const catchphrases = [
            "Anthony: 'HOTPOT?? HOTPOT??'",
            "Carlos: 'Skibidiiiiiiii.'",
            "Anna: 'Does this have milk? ... Whatever, I'm eating it.'",
            "Winni: 'Good morning! (It is 4 PM)'",
            "Winni: 'Hey Bro'",
            "Aimee: 'Wanna eat LiuYiShou tomorrow?'",
            "Erioe: 'Fuck off.'",
            "Carrie: 'So What?'",
            "Aska: Whats your shoe size?",
        ];

        function addDecoration(type, x, y, z, rotationY = 0, scale = 1) {
            let tex;
            if (DecorationSet[type]) {
                tex = createTextureFromCanvas(DecorationSet[type]);
            } else {
                return;
            }
            const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide });
            const geo = new THREE.PlaneGeometry(100 * scale, 100 * scale);
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, y, z);
            mesh.rotation.y = rotationY;
            mesh.userData = { type: 'decoration' };
            scene.add(mesh);
            interactableObjects.push(mesh);
            return mesh;
        }

        // --- Particle Systems ---
        function createParticleSystem(type, startZ, depth) {
            const count = 300;
            const geom = new THREE.BufferGeometry();
            const posArray = new Float32Array(count * 3);
            const speedArray = new Float32Array(count); // Store speed

            for (let i = 0; i < count; i++) {
                posArray[i * 3] = (Math.random() - 0.5) * 550; // x: wide range
                posArray[i * 3 + 1] = (Math.random() - 0.5) * 500; // y
                posArray[i * 3 + 2] = startZ - Math.random() * depth; // z
                speedArray[i] = 0.5 + Math.random();
            }
            geom.setAttribute('position', new THREE.BufferAttribute(posArray, 3));

            let color = 0xffffff;
            let size = 4;
            let op = 0.8;

            if (type === 'spring') { color = 0xffb7b2; size = 6; } // Pink petals
            if (type === 'summer') { color = 0xffea00; size = 8; op = 0.4; } // Sun dust/pollen
            if (type === 'autumn') { color = 0xd35400; size = 7; } // Orange leaves
            if (type === 'winter') { color = 0xffffff; size = 5; } // White snow

            const mat = new THREE.PointsMaterial({
                color: color,
                size: size,
                transparent: true,
                opacity: op
            });

            const points = new THREE.Points(geom, mat);
            scene.add(points);

            particles.push({ mesh: points, type: type, speeds: speedArray, minZ: startZ - depth, maxZ: startZ });
        }

        // --- Helper: Create clickable game button ---
        function createGameButton(text, url, x, y, z, rotationY) {
            const group = new THREE.Group();
            group.position.set(x, y, z);
            group.rotation.y = rotationY;

            // Create button background
            const buttonWidth = 300;
            const buttonHeight = 150;
            const buttonGeo = new THREE.PlaneGeometry(buttonWidth, buttonHeight);
            const buttonMat = new THREE.MeshBasicMaterial({
                color: 0x4a90e2,
                transparent: true,
                opacity: 0.9
            });
            const button = new THREE.Mesh(buttonGeo, buttonMat);
            group.add(button);

            // Create text canvas
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 256;
            const ctx = canvas.getContext('2d');

            // Background
            ctx.fillStyle = '#4a90e2';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 8;
            ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

            // Text
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const lines = text.split('\n');
            ctx.font = 'bold 40px Arial';
            ctx.fillText(lines[0], canvas.width / 2, canvas.height / 2 - 30);

            ctx.font = 'bold 50px Arial';
            ctx.fillText(lines[1], canvas.width / 2, canvas.height / 2 + 30);

            // Apply texture
            const texture = new THREE.CanvasTexture(canvas);
            const textMat = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true
            });
            const textMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(buttonWidth, buttonHeight),
                textMat
            );
            textMesh.position.z = 1;
            group.add(textMesh);

            // Make it interactive - set userData on the mesh itself
            textMesh.userData = { type: 'gameButton', url: url };
            interactableObjects.push(textMesh);

            scene.add(group);
        }

        // --- Ê†∏ÂøÉÂäüËÉΩ 1: Âª∫Á´ãÂõõÂ≠£Áí∞Â¢É ---
        function createSeasonalEnvironment() {
            const segmentDepth = 1600;

            seasonsConfig.forEach((season, index) => {
                const startZ = -(index * segmentDepth) + 400;
                const centerZ = startZ - (segmentDepth / 2);

                // 1. Âú∞Êùø
                const floorGeo = new THREE.PlaneGeometry(600, segmentDepth);
                const floorMat = new THREE.MeshBasicMaterial({ color: season.floor });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, -300, centerZ);
                scene.add(floor);

                // 2. Â§©Ëä±Êùø
                const ceilGeo = new THREE.PlaneGeometry(600, segmentDepth);
                const ceilMat = new THREE.MeshBasicMaterial({ color: season.ceiling });
                const ceil = new THREE.Mesh(ceilGeo, ceilMat);
                ceil.rotation.x = Math.PI / 2;
                ceil.position.set(0, 300, centerZ);
                scene.add(ceil);

                // 3. Â∑¶ÁâÜ
                const wallGeo = new THREE.PlaneGeometry(segmentDepth, 600);
                const wallMat = new THREE.MeshBasicMaterial({ color: season.wall });
                const leftWall = new THREE.Mesh(wallGeo, wallMat);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.position.set(-300, 0, centerZ);
                scene.add(leftWall);

                // 4. Âè≥ÁâÜ
                const rightWall = new THREE.Mesh(wallGeo, wallMat);
                rightWall.rotation.y = -Math.PI / 2;
                rightWall.position.set(300, 0, centerZ);
                scene.add(rightWall);

                // *** Add Decorations based on Season ***
                // Images are at startZ - 400, -800, -1200. We place decorations in gaps: -200, -600, -1000, -1400.
                if (season.id === 'winter') {
                    // Christmas Trees in the gaps on walls
                    addDecoration('ChristmasTree', -280, -100, startZ - 600, Math.PI / 2, 2.5);
                    addDecoration('ChristmasTree', 280, -100, startZ - 1000, -Math.PI / 2, 2.5);
                    // Snowman
                    addDecoration('Snowman', -290, -200, startZ - 200, Math.PI / 2, 2);
                    addDecoration('Snowman', -290, -200, startZ - 1400, -Math.PI / 2, 2);

                    // Mistletoes hanging from ceiling
                    for (let k = 0; k < 5; k++) {
                        addDecoration('Mistletoe', (Math.random() - 0.5) * 400, 250, startZ - Math.random() * segmentDepth, 0, 1.2);
                    }

                    // Special Pink Ice Cream with Santa Hat in the corner
                    const specialItem = addDecoration('PinkSantaIceCream', 290, -100, startZ - 1500, -Math.PI / 2, 2);
                    if (specialItem) specialItem.userData.type = 'special_sundai';
                } else if (season.id === 'spring') {
                    // Flowers in gaps
                    addDecoration('Flower', -290, -150, startZ - 200, Math.PI / 2, 1.5);
                    addDecoration('Flower', 290, -150, startZ - 600, -Math.PI / 2, 1.5);
                    addDecoration('Flower', -290, 100, startZ - 1000, Math.PI / 2, 1);
                    // Butterfly
                    addDecoration('Butterfly', 290, 100, startZ - 1400, -Math.PI / 2, 1.5);
                } else if (season.id === 'summer') {
                    // Sun on ceiling
                    const sun = addDecoration('Sun', 0, 280, centerZ, Math.PI / 2, 3);
                    sun.rotation.x = Math.PI / 2; // face down
                    // Ice Cream
                    addDecoration('IceCream', -290, -150, startZ - 1000, Math.PI / 2, 1.5);
                    addDecoration('IceCream', 290, -150, startZ - 400, -Math.PI / 2, 1.5);
                } else if (season.id === 'autumn') {
                    // Pumpkins on floor/wall edge
                    addDecoration('Pumpkin', -280, -230, startZ - 200, Math.PI / 2, 1.2);
                    addDecoration('Pumpkin', 280, -230, startZ - 1200, -Math.PI / 2, 1.5);
                    // Mushroom
                    addDecoration('Mushroom', -290, -200, startZ - 800, Math.PI / 2, 1.3);
                    addDecoration('Mushroom', 290, -200, startZ - 1400, -Math.PI / 2, 1.3);
                }

                // *** Add Particle System for this season ***
                createParticleSystem(season.id, startZ, segmentDepth);

                // *** ÂâçÁâÜ(ÂÖ•Âè£) ***
                if (index === 0) {
                    const frontWallGeo = new THREE.PlaneGeometry(600, 600);
                    const frontWallMat = new THREE.MeshBasicMaterial({ color: season.wall });
                    const frontWall = new THREE.Mesh(frontWallGeo, frontWallMat);
                    frontWall.rotation.y = Math.PI;
                    frontWall.position.set(0, 0, startZ);
                    scene.add(frontWall);

                    createGameButton('Press Here to Play\nMatching Game', 'game/index.html', 0, 0, startZ - 5, Math.PI);
                }

                // *** ÂæåÁâÜ(Âá∫Âè£) ***
                if (index === seasonsConfig.length - 1) {
                    const backWallGeo = new THREE.PlaneGeometry(600, 600);
                    const backWallMat = new THREE.MeshBasicMaterial({ color: season.wall });
                    const backWall = new THREE.Mesh(backWallGeo, backWallMat);
                    backWall.position.set(0, 0, startZ - segmentDepth);
                    scene.add(backWall);

                    createGameButton('Press Here to Play\nRPG Game', 'RPG/rpg_memories.html', 0, 0, startZ - segmentDepth + 5, 0);
                }
            });
        }

        // --- Ê†∏ÂøÉÂäüËÉΩ 2: Âª∫Á´ãÊúãÂèãÊòüÊòü ---
        function createFriendStars() {
            friendsData.forEach((friend, index) => {
                const zPos = -index * SPACING;
                const star = createStarMesh(friend.name, friend.title);
                star.rotation.x = -Math.PI / 2;
                star.position.set(0, -298, zPos);
                star.userData = { type: 'friend', data: friend };
                scene.add(star);
                interactableObjects.push(star);
            });
        }

        // --- Ê†∏ÂøÉÂäüËÉΩ 3: Ê®ôÊ∫ñÂåñÁï´Ê°ÜÊéíÂàó ---
        function createStandardGallery() {
            const loader = new THREE.TextureLoader();
            const segmentDepth = 1600;

            seasonsConfig.forEach((season, sIndex) => {
                const imagesPerSide = 3;
                const seasonStartZ = -(sIndex * segmentDepth) + 400;
                const gap = segmentDepth / (imagesPerSide + 1);

                for (let i = 0; i < imagesPerSide; i++) {
                    const zPos = seasonStartZ - (gap * (i + 1));
                    // Â∑¶ÁâÜ
                    createSingleFrame(`${season.artFolder}/image-0${i + 1}.jpg`, -295, 0, zPos, true, season.floor);
                    // Âè≥ÁâÜ
                    createSingleFrame(`${season.artFolder}/image-0${i + 4}.jpg`, 295, 0, zPos, false, season.floor);
                }
            });

            function createSingleFrame(path, x, y, z, isLeft, fallbackColor) {
                const group = new THREE.Group();
                group.position.set(x, y, z);
                group.rotation.y = isLeft ? Math.PI / 2 : -Math.PI / 2;

                const defaultWidth = 150;
                const defaultHeight = 110;
                const frameThickness = 5;
                const framePadding = 5;

                let frameGeo = new THREE.BoxGeometry(defaultWidth + framePadding * 2, defaultHeight + framePadding * 2, frameThickness);
                const frameMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
                let frame = new THREE.Mesh(frameGeo, frameMat);
                group.add(frame);

                let canvasGeo = new THREE.PlaneGeometry(defaultWidth, defaultHeight);
                const canvasMat = new THREE.MeshBasicMaterial({ color: fallbackColor });
                let painting = new THREE.Mesh(canvasGeo, canvasMat);
                painting.position.z = 3;
                group.add(painting);

                loader.load(path, (tex) => {
                    const img = tex.image;
                    const aspectRatio = img.width / img.height;
                    const maxHeight = 200;
                    let finalHeight = maxHeight;
                    let finalWidth = finalHeight * aspectRatio;
                    const maxWidth = 250;
                    if (finalWidth > maxWidth) {
                        finalWidth = maxWidth;
                        finalHeight = finalWidth / aspectRatio;
                    }
                    group.remove(frame);
                    group.remove(painting);

                    frameGeo = new THREE.BoxGeometry(finalWidth + framePadding * 2, finalHeight + framePadding * 2, frameThickness);
                    frame = new THREE.Mesh(frameGeo, frameMat);
                    group.add(frame);

                    canvasGeo = new THREE.PlaneGeometry(finalWidth, finalHeight);
                    painting = new THREE.Mesh(canvasGeo, new THREE.MeshBasicMaterial({ map: tex }));
                    painting.position.z = 3;
                    group.add(painting);
                }, undefined, (err) => { });

                scene.add(group);
            }
        }

        function createStarMesh(name, title) {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 512, 512);

            ctx.translate(256, 256);
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * 140, -Math.sin((18 + i * 72) * Math.PI / 180) * 140);
                ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * 60, -Math.sin((54 + i * 72) * Math.PI / 180) * 60);
            }
            ctx.closePath();
            ctx.fillStyle = '#ffd700'; ctx.fill();

            ctx.font = 'bold 50px Arial';
            ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center';
            ctx.fillText(name, 0, 200);

            ctx.font = '30px Arial';
            ctx.fillStyle = '#ffecb3';
            ctx.fillText(title, 0, 240);

            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 15;
            ctx.strokeRect(-250, -250, 500, 500);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
            const geometry = new THREE.PlaneGeometry(300, 300);
            return new THREE.Mesh(geometry, material);
        }

        function addEntranceText() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#d86a95'; ctx.font = 'bold 100px serif';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

            const texture = new THREE.CanvasTexture(canvas);
            const planeGeom = new THREE.PlaneGeometry(300, 150);
            const planeMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
            const textPlane = new THREE.Mesh(planeGeom, planeMat);
            textPlane.rotation.x = Math.PI / 6;
            textPlane.position.set(0, 150, 400);
            scene.add(textPlane);
        }

        // --- ‰∫íÂãïÈÇèËºØ ---
        function onMouseClick(event) {
            if (isDragging) return;
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(interactableObjects);
            if (intersects.length > 0) {
                const obj = intersects[0].object;
                const data = obj.userData;

                if (data.type === 'friend') {
                    openModal(data.data.name, data.data.title, data.data.desc, data.data.file);
                } else if (data.type === 'gameButton') {
                    window.location.href = data.url;
                } else if (data.type === 'special_sundai') {
                    // Initialize slideshow with all 5 sundai images
                    slideshowImages = [
                        "3d_images/sundai-01.jpg",
                        "3d_images/sundai-02.jpg",
                        "3d_images/sundai-03.jpg",
                        "3d_images/sundai-04.jpg",
                        "3d_images/sundai-05.jpg"
                    ];
                    currentSlideIndex = 0;
                    slideshowActive = true;
                    openModal("Sundai Club Surprise!", "Merry Christmas Everyone!", "Enjoy this special holiday treat!", slideshowImages[0]);
                } else if (data.type === 'decoration') {
                    const isPhotoSurprise = Math.random() > 0.2;
                    if (isPhotoSurprise) {
                        const randomNum = Math.floor(Math.random() * 60) + 1;
                        const numStr = randomNum.toString().padStart(2, '0');
                        const imgPath = `3d_images/surprise/image-${numStr}.jpg`;
                        openModal("SURPRISE!", "‚ö†Ô∏è EXPOSED ‚ö†Ô∏è", "You found a secret memory! Hope you are ready for this...", imgPath);
                    } else {
                        const randomQuote = catchphrases[Math.floor(Math.random() * catchphrases.length)];
                        openModal("Overheard...", "üí¨ Catchphrase", randomQuote, null);
                    }
                }
            }
        }

        function openModal(name, title, desc, imgSrc) {
            const overlay = document.getElementById('modal-overlay');
            const imgElement = document.getElementById('modal-img');
            const slideshowControls = document.getElementById('slideshow-controls');

            document.getElementById('modal-name').innerText = name;
            document.getElementById('modal-title').innerText = title;
            document.getElementById('modal-desc').innerText = desc;

            if (imgSrc) {
                imgElement.src = imgSrc;
                imgElement.style.display = 'block';
                // Add slide-in animation
                imgElement.classList.remove('slide-in');
                void imgElement.offsetWidth; // Trigger reflow
                imgElement.classList.add('slide-in');
            } else {
                imgElement.style.display = 'none';
            }

            // Show/hide slideshow controls
            if (slideshowActive) {
                slideshowControls.classList.add('active');
                updateSlideCounter();
            } else {
                slideshowControls.classList.remove('active');
            }

            overlay.style.display = 'flex';
            setTimeout(() => {
                overlay.style.opacity = '1';
                document.getElementById('modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeModal() {
            const overlay = document.getElementById('modal-overlay');
            overlay.style.opacity = '0';
            document.getElementById('modal-content').style.transform = 'scale(0.8)';
            setTimeout(() => {
                overlay.style.display = 'none';
                // Reset slideshow state
                slideshowActive = false;
                currentSlideIndex = 0;
                slideshowImages = [];
            }, 300);
        }

        function navigateSlide(direction) {
            if (!slideshowActive || slideshowImages.length === 0) return;

            currentSlideIndex += direction;

            // Loop around
            if (currentSlideIndex < 0) {
                currentSlideIndex = slideshowImages.length - 1;
            } else if (currentSlideIndex >= slideshowImages.length) {
                currentSlideIndex = 0;
            }

            // Update image with animation
            const imgElement = document.getElementById('modal-img');
            imgElement.classList.remove('slide-in');
            void imgElement.offsetWidth; // Trigger reflow
            imgElement.src = slideshowImages[currentSlideIndex];
            imgElement.classList.add('slide-in');

            updateSlideCounter();
        }

        function updateSlideCounter() {
            const counter = document.getElementById('slide-counter');
            counter.innerText = `${currentSlideIndex + 1} / ${slideshowImages.length}`;
        }

        function onPointerDown(event) {
            isUserInteracting = true; isDragging = false;
            onPointerDownPointerX = event.clientX; onPointerDownPointerY = event.clientY;
            onPointerDownLon = lon; onPointerDownLat = lat;
        }
        function onPointerMove(event) {
            if (isUserInteracting === true) {
                if (Math.abs(event.clientX - onPointerDownPointerX) > 5) isDragging = true;
                lon = (onPointerDownPointerX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownPointerY) * 0.1 + onPointerDownLat;
            }
        }
        // --- Mobile Logic Functions ---
        // --- Mobile Logic Functions ---
        function requestOrientationPermission() {
            if (!window.isSecureContext) {
                alert("HTTPS is required for Gyroscope.");
                return;
            }
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                Promise.all([
                    DeviceOrientationEvent.requestPermission(),
                    (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
                        ? DeviceMotionEvent.requestPermission()
                        : Promise.resolve('granted')
                ]).then(([orientationState, motionState]) => {
                    if (orientationState === 'granted') {
                        window.addEventListener('deviceorientation', handleOrientation);
                        document.getElementById('permission-overlay').style.display = 'none';
                    } else {
                        alert("Permission denied.");
                        document.getElementById('permission-overlay').style.display = 'none';
                    }
                }).catch(console.error);
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
                document.getElementById('permission-overlay').style.display = 'none';
            }
        }

        function handleOrientation(event) {
            // Using user reference logic
            if (isUserInteracting) return;
            if (baseAlpha === null && event.alpha !== null) {
                baseAlpha = event.alpha;
            }
            if (event.alpha !== null) {
                // In reference: lon = alpha - baseAlpha
                // We apply this directly but watch for inversion if needed.
                // Standard gyro look around:
                lon = (baseAlpha - event.alpha);
                lat = (event.beta - 90);
            }
        }

        function initMobileControls() {
            const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || window.innerWidth < 768;
            if (isMobile) {
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    document.getElementById('permission-overlay').style.display = 'flex';
                } else {
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            }
        }

        function onPointerUp() { isUserInteracting = false; }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                isUserInteracting = true; isDragging = false;
                onPointerDownPointerX = event.touches[0].clientX; onPointerDownPointerY = event.touches[0].clientY;
                onPointerDownLon = lon; onPointerDownLat = lat;
            } else if (event.touches.length === 2) {
                isTwoFingerTouching = true;
                event.preventDefault();
            }
        }
        function onTouchMove(event) {
            if (event.touches.length === 1 && isUserInteracting) {
                isDragging = true; event.preventDefault();
                lon = (onPointerDownPointerX - event.touches[0].clientX) * 0.2 + onPointerDownLon;
                lat = (event.touches[0].clientY - onPointerDownPointerY) * 0.2 + onPointerDownLat;
            } else if (event.touches.length === 2) {
                isTwoFingerTouching = true;
                event.preventDefault();
            }
        }
        function onTouchEnd(event) {
            isUserInteracting = false;
            if (event.touches.length < 2) isTwoFingerTouching = false;
        }
        function onDocumentMouseWheel(event) { targetZ += event.deltaY * 0.5; }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() { requestAnimationFrame(animate); update(); }

        function update() {
            // Camera Position Logic (Shared)
            cameraZ += (targetZ - cameraZ) * 0.1;
            const maxDepth = -(4 * SEASON_LENGTH) - 1000;
            if (cameraZ > 350) { cameraZ = 350; targetZ = 350; }
            if (cameraZ < maxDepth) { cameraZ = maxDepth; targetZ = maxDepth; }
            camera.position.set(0, 0, cameraZ);

            // Handle 2-Finger Movement Directionally
            if (isTwoFingerTouching) {
                const dir = new THREE.Vector3();
                camera.getWorldDirection(dir);
                targetZ += dir.z * 15;
            }

            // Particles Animation
            particles.forEach(sys => {
                const positions = sys.mesh.geometry.attributes.position.array;
                for (let i = 0; i < 300; i++) {
                    positions[i * 3 + 1] -= sys.speeds[i]; // move down
                    if (positions[i * 3 + 1] < -250) { positions[i * 3 + 1] = 250; }
                    if (sys.type === 'winter' || sys.type === 'autumn' || sys.type === 'spring') {
                        positions[i * 3] += Math.sin(Date.now() * 0.001 + i) * 0.5;
                    }
                }
                sys.mesh.geometry.attributes.position.needsUpdate = true;
            });

            // Camera Rotation (Lat/Lon)
            lat = Math.max(-85, Math.min(85, lat));
            let phi = THREE.MathUtils.degToRad(90 - lat);
            let theta = THREE.MathUtils.degToRad(lon);

            camera.lookAt(
                500 * Math.sin(phi) * Math.cos(theta),
                500 * Math.cos(phi),
                500 * Math.sin(phi) * Math.sin(theta) + cameraZ
            );

            renderer.render(scene, camera);
        }


        // Start initialization after all definitions are ready
        init();
        initMobileControls();
        animate();
    </script>
</body>

</html>